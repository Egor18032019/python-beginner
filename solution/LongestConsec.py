def longest_consec(strarr, k):
    # Проверяем входные данные
    if not strarr or k > len(strarr) or k <= 0:
        return ""

    # Инициализируем переменную для хранения максимальной длины строки
    max_len = 0
    # Инициализируем переменную для хранения индекса начала самой длинной строки
    start = 0

    # Проходим по всем возможным начальным точкам подмассивов
    for i in range(len(strarr) - k + 1):
        # Вычисляем текущую подстроку, состоящую из k последовательных элементов
        current_str = ''.join(strarr[i:i + k])  # // все элементы от i до i+k не включительно=> 0:0+2 ->[0] + [1]
        # Если длина текущей подстроки больше максимальной найденной ранее
        if len(current_str) > max_len:
            # Обновляем максимальную длину и индекс начала подстроки
            max_len = len(current_str)
            start = i

        # Возвращаем самую длинную строку, состоящую из k последовательных элементов
    return ''.join(strarr[start:start + k])


print(longest_consec(["zone", "abigail", "theta", "form", "libe", "zas"], 2))  # -> "abigailtheta"
